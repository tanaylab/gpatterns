---
title: "Basic analysis workflow"
author: "Aviezer Lifshitz"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic analysis workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  fig.width = 9,
  cache = TRUE,
  warning = FALSE
)
```

The package provides functions to assist analyzing 5mC data. The basic analytic workflow consists of the following steps:

* f
*  

## Data: UMI-RRBS of Breast and Lung tumors
To explore gpatterns' functions, we'll start with a dataset of UMI-RRBS of breast and lung tumors. 
The dataset contains 16 breast tumors samples from 4 patients, with multiple sections from each sample. 

* table

After importing the data, we can check that we have all the necessary tracks:
```{r}
library(gpatterns)
gsetroot('/home/aviezerl/hg19')
options(gmax.data.size=1e09)
tracks <- gpatterns.ls('gpatterns_nugget.+')
tracks
```

And remove the prefix for plotting track names:
```{r}
names <- gsub('gpatterns_nugget.', '', tracks)
names
```


## Global methylation 
Next, we will look at the methylation globally:
```{r}
trend <- gpatterns.global_meth_trend(tracks, names=names, xlab='CG content (500bp)')
```

the resulting object has 2 fields. 'trend' with the data, and 'p' with the plot:

```{r}
trend$trend
```
```{r}
trend$p
```

Next, we will look at average methylation in different genomic contexts:

##### tss
```{r}
trend <- gpatterns.spatial_meth_trend(tracks, names=names, intervals='tss')
trend$p
```

##### exons
```{r}
trend <- gpatterns.spatial_meth_trend(tracks, names=names, intervals='exon')
trend$p
```

##### CpG islands
```{r}
trend <- gpatterns.spatial_meth_trend(tracks, names=names, intervals='cgi', dist_breaks = seq(0,100,20))
trend$p
```

## Correlations between CpGs
```{r}
trend <- gpatterns.plot_cg_cor(tracks, names=names, adjacent=TRUE, dist_breaks = seq(0,200,20), min_cgs=100)
trend$p
```

We can repeat that in different genomic contexts as well: 
```{r}
trend <- gpatterns.plot_cg_cor(tracks, names=names, adjacent=TRUE, dist_breaks = seq(0,200,20), min_cgs=100, intervals='cgi')
trend$p
```


## Epipolymorphism
In order to calculate epipolymorphism we first need to define the CpG scope, or 'pattern space' and create the patterns attributes of our tracks, see `import` vignette for details. Assuming we defined a pattern space and created generated patterns for our tracks, we can plot epipolymorphism for different methylation regimes and genomic scopes: 
```{r, fig.height=4}
gpatterns.epipoly_plot(tracks[c(1,5,13)], gintervals.all(), colnames=names[c(1,5,13)])
```

And again, in different genomic contexts:
```{r, fig.height=4}
gpatterns.epipoly_plot(tracks[c(1,5,13)], intervals='tss', colnames=names[c(1,5,13)])
```


## Clustering
First step for multiple sample analysis is to retrieve the methylation calls in a joined set of CpGs. gpatterns provides a function for that purpose. Given genomic regions `gpatterns.get_avg_meth` screens for the places that have enough coverage (`min_cov`) in enough samples (`min_samples`), and extracts methylation calls in those regions. In addition, there is an options to screen for the most variable regions (`var_quantile` and `min_var`), and for minimal number of CpGs per region (`min_cpgs`). If no iterator is given the function uses CpGs is the given intervals.

Let's extract the 10% most variable CpGs that have at least 20 methylation calls in at least 15 samples:
```{r, eval = FALSE}
avgs <- gpatterns.get_avg_meth(tracks=tracks, intervals='intervs.msp1.fid', var_quantile=0.1, names=names, min_cov=20, min_samples=15)
avgs
```

Now we can cluster the average methylation using kmeans++: 
```{r, eval = FALSE}
clust <- gpatterns.cluster_avg_meth(avgs, K=10)
clust
```

And plot the clustering:

